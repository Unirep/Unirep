"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const hardhat_1 = require("hardhat");
const chai_1 = require("chai");
const crypto_1 = require("@unirep/crypto");
const circuits_1 = require("@unirep/circuits");
const contracts_1 = require("@unirep/contracts");
const core_1 = require("../../core");
const utils_1 = require("../utils");
describe('Generate user state', function () {
    this.timeout(500000);
    let users = new Array(2);
    const firstUser = 0;
    const secondUser = 1;
    let userIds = [];
    let userCommitments = [];
    let savedUserState;
    let secondUserState;
    let unirepContract;
    let unirepContractCalledByAttester;
    let _treeDepths;
    let accounts;
    const attester = new Object();
    let attesterId;
    before(async () => {
        accounts = await hardhat_1.ethers.getSigners();
        _treeDepths = (0, utils_1.getTreeDepthsForTesting)("circuit");
        const _settings = {
            maxUsers: core_1.maxUsers,
            maxAttesters: core_1.maxAttesters,
            numEpochKeyNoncePerEpoch: core_1.numEpochKeyNoncePerEpoch,
            maxReputationBudget: core_1.maxReputationBudget,
            epochLength: core_1.epochLength,
            attestingFee: core_1.attestingFee
        };
        unirepContract = await (0, contracts_1.deployUnirep)(accounts[0], _treeDepths, _settings);
    });
    describe('Attester sign up and set airdrop', () => {
        it('attester sign up', async () => {
            attester['acct'] = accounts[2];
            attester['addr'] = await attester['acct'].getAddress();
            unirepContractCalledByAttester = unirepContract.connect(attester['acct']);
            let tx = await unirepContractCalledByAttester.attesterSignUp();
            let receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Attester signs up failed').to.equal(1);
        });
        it('attester set airdrop amount', async () => {
            const airdropPosRep = 10;
            const tx = await unirepContractCalledByAttester.setAirdropAmount(airdropPosRep);
            const receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status).equal(1);
            const airdroppedAmount = await unirepContract.airdropAmount(attester['addr']);
            (0, chai_1.expect)(airdroppedAmount.toNumber()).equal(airdropPosRep);
        });
    });
    describe('User Sign Up event', () => {
        it('users sign up events', async () => {
            var _a;
            const id = (0, crypto_1.genIdentity)();
            const commitment = (0, crypto_1.genIdentityCommitment)(id);
            userIds.push(id);
            userCommitments.push(commitment);
            const initUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            const tx = await unirepContractCalledByAttester.userSignUp(commitment);
            const receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'User sign up failed').to.equal(1);
            const currentEpoch = initUserState.getUnirepStateCurrentEpoch();
            const latestTransitionedToEpoch = currentEpoch;
            const UserSignedUpFilter = unirepContract.filters.UserSignedUp(currentEpoch);
            const userSignedUpEvents = await unirepContract.queryFilter(UserSignedUpFilter);
            (0, chai_1.expect)(userSignedUpEvents.length).equal(1);
            const args = (_a = userSignedUpEvents[0]) === null || _a === void 0 ? void 0 : _a.args;
            const _commitment = BigInt(args === null || args === void 0 ? void 0 : args._identityCommitment);
            (0, chai_1.expect)(_commitment).equal(userCommitments[firstUser]);
            let startTime = new Date().getTime();
            users[firstUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser], JSON.parse(initUserState.toJSON()));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            (0, chai_1.expect)(restoredUserState.toJSON()).equal(users[firstUser].toJSON());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(restoredUserState.toJSON()));
            (0, chai_1.expect)(restoredUserStateFromParams.toJSON()).equal(users[firstUser].toJSON());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            (0, chai_1.expect)(users[firstUser].latestTransitionedEpoch).equal(latestTransitionedToEpoch);
            console.log(`First user signs up with commitment (${commitment}), in epoch ${users[firstUser].latestTransitionedEpoch} and GST leaf ${users[firstUser].latestGSTLeafIndex}`);
            console.log('----------------------User State----------------------');
            console.log(users[firstUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[firstUser].toJSON(4);
        });
        it('users sign up events', async () => {
            const id = (0, crypto_1.genIdentity)();
            const commitment = (0, crypto_1.genIdentityCommitment)(id);
            userIds.push(id);
            userCommitments.push(commitment);
            const tx = await unirepContractCalledByAttester.userSignUp(commitment);
            const receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'User sign up failed').to.equal(1);
            users[secondUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[secondUser]);
            console.log('----------- second user state ---------------');
            console.log(users[secondUser].toJSON(4));
            console.log('----------- end of second user state ---------------');
            secondUserState = users[secondUser].toJSON();
        });
    });
    describe('Attestation submitted event', () => {
        it('epoch key proof event', async () => {
            const userState = (0, core_1.genUserStateFromParams)(userIds[secondUser], JSON.parse(secondUserState));
            const epochKeyNonce = 2;
            const { proof, publicSignals } = await userState.genVerifyEpochKeyProof(epochKeyNonce);
            const epochKeyProof = new contracts_1.EpochKeyProof(publicSignals, proof);
            const isValid = await epochKeyProof.verify();
            (0, chai_1.expect)(isValid, 'Verify epk proof off-chain failed').to.be.true;
            let tx = await unirepContract.submitEpochKeyProof(epochKeyProof);
            let receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status).equal(1);
            const proofIndex = await unirepContract.getProofIndex(epochKeyProof.hash());
            (0, chai_1.expect)(proofIndex.toNumber()).not.equal(0);
            const fromProofIndex = 0;
            attesterId = BigInt(await unirepContract.attesters(attester['addr']));
            const attestation = (0, utils_1.genRandomAttestation)();
            attestation.attesterId = attesterId;
            tx = await unirepContractCalledByAttester.submitAttestation(attestation, epochKeyProof.epochKey, proofIndex, fromProofIndex, { value: core_1.attestingFee });
            receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Submit attestation failed').to.equal(1);
        });
        it('restored user state should match the user state after epoch key proof event', async () => {
            let startTime = new Date().getTime();
            users[firstUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser], JSON.parse(savedUserState));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            (0, chai_1.expect)(restoredUserState.toJSON()).equal(users[firstUser].toJSON());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(restoredUserState.toJSON()));
            (0, chai_1.expect)(restoredUserStateFromParams.toJSON()).equal(users[firstUser].toJSON());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const unirepEpoch = await unirepContract.currentEpoch();
            const currentEpoch = users[firstUser].getUnirepStateCurrentEpoch();
            (0, chai_1.expect)(currentEpoch).equal(unirepEpoch);
            console.log(`successfully update user state`);
            console.log('----------------------User State----------------------');
            console.log(users[firstUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[firstUser].toJSON(4);
        });
        it('reputation proof event', async () => {
            const userState = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(savedUserState));
            const epochKeyNonce = 1;
            const minRep = 0;
            const proveGraffiti = BigInt(0);
            const graffitiPreimage = BigInt(0);
            const nonceList = [BigInt(0), BigInt(1), BigInt(-1), BigInt(-1), BigInt(-1), BigInt(-1), BigInt(-1), BigInt(-1), BigInt(-1), BigInt(-1)];
            const { proof, publicSignals } = await userState.genProveReputationProof(attesterId, epochKeyNonce, minRep, proveGraffiti, graffitiPreimage, nonceList);
            const reputationProof = new contracts_1.ReputationProof(publicSignals, proof);
            const isValid = await reputationProof.verify();
            (0, chai_1.expect)(isValid, 'Verify epk proof off-chain failed').to.be.true;
            const tx = await unirepContractCalledByAttester.spendReputation(reputationProof, { value: core_1.attestingFee });
            const receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Submit reputation nullifiers failed').to.equal(1);
            const proofIndex = await unirepContract.getProofIndex(reputationProof.hash());
            (0, chai_1.expect)(proofIndex.toNumber()).not.equal(0);
        });
        it('restored user state should match the user state after reputation proof event', async () => {
            let startTime = new Date().getTime();
            users[firstUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser], JSON.parse(savedUserState));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            (0, chai_1.expect)(restoredUserState.toJSON()).equal(users[firstUser].toJSON());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(restoredUserState.toJSON()));
            (0, chai_1.expect)(restoredUserStateFromParams.toJSON()).equal(users[firstUser].toJSON());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const unirepEpoch = await unirepContract.currentEpoch();
            const currentEpoch = users[firstUser].getUnirepStateCurrentEpoch();
            (0, chai_1.expect)(currentEpoch).equal(unirepEpoch);
            console.log(`successfully update user state`);
            console.log('----------------------User State----------------------');
            console.log(users[firstUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[firstUser].toJSON(4);
        });
        it('airdrop proof event', async () => {
            const userState = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(savedUserState));
            const { proof, publicSignals } = await userState.genUserSignUpProof(attesterId);
            const userSignUpProof = new contracts_1.SignUpProof(publicSignals, proof);
            const isValid = await userSignUpProof.verify();
            (0, chai_1.expect)(isValid, 'Verify epk proof off-chain failed').to.be.true;
            const tx = await unirepContractCalledByAttester.airdropEpochKey(userSignUpProof, { value: core_1.attestingFee, gasLimit: 1000000 });
            const receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Submit airdrop proof failed').to.equal(1);
            const proofIndex = await unirepContract.getProofIndex(userSignUpProof.hash());
            (0, chai_1.expect)(proofIndex.toNumber()).not.equal(0);
        });
        it('restored user state should match the user state after airdrop proof event', async () => {
            let startTime = new Date().getTime();
            users[firstUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser], JSON.parse(savedUserState));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            (0, chai_1.expect)(restoredUserState.toJSON()).equal(users[firstUser].toJSON());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(restoredUserState.toJSON()));
            (0, chai_1.expect)(restoredUserStateFromParams.toJSON()).equal(users[firstUser].toJSON());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const unirepEpoch = await unirepContract.currentEpoch();
            const currentEpoch = users[firstUser].getUnirepStateCurrentEpoch();
            (0, chai_1.expect)(currentEpoch).equal(unirepEpoch);
            console.log(`successfully update user state`);
            console.log('----------------------User State----------------------');
            console.log(users[firstUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[firstUser].toJSON(4);
        });
    });
    describe('Epoch transition event', () => {
        it('epoch transition', async () => {
            // Fast-forward epochLength of seconds
            await hardhat_1.ethers.provider.send("evm_increaseTime", [core_1.epochLength]);
            // Begin epoch transition
            const tx = await unirepContract.beginEpochTransition();
            const receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status).equal(1);
        });
        it('restored user state should match the user state after epoch transition', async () => {
            let startTime = new Date().getTime();
            users[firstUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser], JSON.parse(savedUserState));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const epoch = 1;
            const epochTreeRoot = await users[firstUser].getUnirepStateEpochTree(epoch);
            const restoredEpochTreeRoot = await restoredUserState.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredEpochTreeRoot.toString()).equal(epochTreeRoot.toString());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(restoredUserState.toJSON()));
            const restoredEpochTreeRootFromParams = await restoredUserStateFromParams.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredEpochTreeRootFromParams.toString()).equal(epochTreeRoot.toString());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const unirepEpoch = await unirepContract.currentEpoch();
            const currentEpoch = users[firstUser].getUnirepStateCurrentEpoch();
            (0, chai_1.expect)(currentEpoch).equal(unirepEpoch);
            console.log(`successfully update user state`);
            console.log('----------------------User State----------------------');
            console.log(users[firstUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[firstUser].toJSON(4);
        });
        it('user state transition', async () => {
            const proofIndexes = [];
            const userState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            const { startTransitionProof, processAttestationProofs, finalTransitionProof, } = await userState.genUserStateTransitionProofs();
            let isValid = await (0, circuits_1.verifyProof)(circuits_1.Circuit.startTransition, startTransitionProof.proof, startTransitionProof.publicSignals);
            (0, chai_1.expect)(isValid, 'Verify start transition circuit off-chain failed').to.be.true;
            const blindedUserState = startTransitionProof.blindedUserState;
            const blindedHashChain = startTransitionProof.blindedHashChain;
            const globalStateTree = startTransitionProof.globalStateTreeRoot;
            const proof = (0, circuits_1.formatProofForVerifierContract)(startTransitionProof.proof);
            let tx = await unirepContract.startUserStateTransition(blindedUserState, blindedHashChain, globalStateTree, proof);
            let receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Submit user state transition proof failed').to.equal(1);
            console.log("Gas cost of submit a start transition proof:", receipt.gasUsed.toString());
            let proofNullifier = (0, contracts_1.computeStartTransitionProofHash)(blindedUserState, blindedHashChain, globalStateTree, proof);
            let proofIndex = await unirepContract.getProofIndex(proofNullifier);
            proofIndexes.push(proofIndex);
            for (let i = 0; i < processAttestationProofs.length; i++) {
                isValid = await (0, circuits_1.verifyProof)(circuits_1.Circuit.processAttestations, processAttestationProofs[i].proof, processAttestationProofs[i].publicSignals);
                (0, chai_1.expect)(isValid, 'Verify process attestations circuit off-chain failed').to.be.true;
                const outputBlindedUserState = processAttestationProofs[i].outputBlindedUserState;
                const outputBlindedHashChain = processAttestationProofs[i].outputBlindedHashChain;
                const inputBlindedUserState = processAttestationProofs[i].inputBlindedUserState;
                // submit random process attestations should success and not affect the results
                const falseInput = (0, crypto_1.genRandomSalt)();
                tx = await unirepContract.processAttestations(outputBlindedUserState, outputBlindedHashChain, falseInput, (0, circuits_1.formatProofForVerifierContract)(processAttestationProofs[i].proof));
                receipt = await tx.wait();
                (0, chai_1.expect)(receipt.status, 'Submit process attestations proof failed').to.equal(1);
                tx = await unirepContract.processAttestations(outputBlindedUserState, outputBlindedHashChain, inputBlindedUserState, (0, circuits_1.formatProofForVerifierContract)(processAttestationProofs[i].proof));
                receipt = await tx.wait();
                (0, chai_1.expect)(receipt.status, 'Submit process attestations proof failed').to.equal(1);
                console.log("Gas cost of submit a process attestations proof:", receipt.gasUsed.toString());
                const proofNullifier = (0, contracts_1.computeProcessAttestationsProofHash)(outputBlindedUserState, outputBlindedHashChain, inputBlindedUserState, (0, circuits_1.formatProofForVerifierContract)(processAttestationProofs[i].proof));
                const proofIndex = await unirepContract.getProofIndex(proofNullifier);
                proofIndexes.push(proofIndex);
            }
            isValid = await (0, circuits_1.verifyProof)(circuits_1.Circuit.userStateTransition, finalTransitionProof.proof, finalTransitionProof.publicSignals);
            (0, chai_1.expect)(isValid, 'Verify user state transition circuit off-chain failed').to.be.true;
            const transitionProof = new contracts_1.UserTransitionProof(finalTransitionProof.publicSignals, finalTransitionProof.proof);
            tx = await unirepContract.updateUserStateRoot(transitionProof, proofIndexes);
            receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Submit user state transition proof failed').to.equal(1);
            console.log("Gas cost of submit a user state transition proof:", receipt.gasUsed.toString());
        });
        it('restored user state should match the user state after user state transition', async () => {
            let startTime = new Date().getTime();
            users[firstUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[firstUser], JSON.parse(savedUserState));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const epoch = 1;
            const epochTreeRoot = await users[firstUser].getUnirepStateEpochTree(epoch);
            const restoredEpochTreeRoot = await restoredUserState.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredEpochTreeRoot.toString()).equal(epochTreeRoot.toString());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[firstUser], JSON.parse(restoredUserState.toJSON()));
            const restoredEpochTreeRootFromParams = await restoredUserStateFromParams.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredEpochTreeRootFromParams.toString()).equal(epochTreeRoot.toString());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const unirepEpoch = await unirepContract.currentEpoch();
            const currentEpoch = users[firstUser].getUnirepStateCurrentEpoch();
            (0, chai_1.expect)(currentEpoch).equal(unirepEpoch);
            console.log(`successfully update user state`);
            console.log('----------------------User State----------------------');
            console.log(users[firstUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[firstUser].toJSON(4);
        });
        it('epoch transition', async () => {
            // Fast-forward epochLength of seconds
            await hardhat_1.ethers.provider.send("evm_increaseTime", [core_1.epochLength]);
            // Begin epoch transition
            const tx = await unirepContract.beginEpochTransition();
            const receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status).equal(1);
        });
        it('restored user state should match the user state after user state transition', async () => {
            let startTime = new Date().getTime();
            users[secondUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[secondUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[secondUser], JSON.parse(secondUserState));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const epoch = 1;
            const epochTreeRoot = await users[secondUser].getUnirepStateEpochTree(epoch);
            const restoredEpochTreeRoot = await restoredUserState.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredUserState.toJSON()).equal(users[secondUser].toJSON());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[secondUser], JSON.parse(restoredUserState.toJSON()));
            const restoredEpochTreeRootFromParams = await restoredUserStateFromParams.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredUserStateFromParams.toJSON()).equal(users[secondUser].toJSON());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const unirepEpoch = await unirepContract.currentEpoch();
            const currentEpoch = users[secondUser].getUnirepStateCurrentEpoch();
            (0, chai_1.expect)(currentEpoch).equal(unirepEpoch);
            console.log(`successfully update user state`);
            console.log('----------------------User State----------------------');
            console.log(users[secondUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[secondUser].toJSON(4);
        });
        it('user state transition', async () => {
            const proofIndexes = [];
            const userState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[secondUser]);
            const { startTransitionProof, processAttestationProofs, finalTransitionProof } = await userState.genUserStateTransitionProofs();
            let isValid = await (0, circuits_1.verifyProof)(circuits_1.Circuit.startTransition, startTransitionProof.proof, startTransitionProof.publicSignals);
            (0, chai_1.expect)(isValid, 'Verify start transition circuit off-chain failed').to.be.true;
            const blindedUserState = startTransitionProof.blindedUserState;
            const blindedHashChain = startTransitionProof.blindedHashChain;
            const globalStateTree = startTransitionProof.globalStateTreeRoot;
            const proof = (0, circuits_1.formatProofForVerifierContract)(startTransitionProof.proof);
            let tx = await unirepContract.startUserStateTransition(blindedUserState, blindedHashChain, globalStateTree, proof);
            let receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Submit user state transition proof failed').to.equal(1);
            console.log("Gas cost of submit a start transition proof:", receipt.gasUsed.toString());
            let proofNullifier = (0, contracts_1.computeStartTransitionProofHash)(blindedUserState, blindedHashChain, globalStateTree, proof);
            let proofIndex = await unirepContract.getProofIndex(proofNullifier);
            proofIndexes.push(proofIndex);
            for (let i = 0; i < processAttestationProofs.length; i++) {
                isValid = await (0, circuits_1.verifyProof)(circuits_1.Circuit.processAttestations, processAttestationProofs[i].proof, processAttestationProofs[i].publicSignals);
                (0, chai_1.expect)(isValid, 'Verify process attestations circuit off-chain failed').to.be.true;
                const outputBlindedUserState = processAttestationProofs[i].outputBlindedUserState;
                const outputBlindedHashChain = processAttestationProofs[i].outputBlindedHashChain;
                const inputBlindedUserState = processAttestationProofs[i].inputBlindedUserState;
                // submit random process attestations should success and not affect the results
                const falseInput = (0, crypto_1.genRandomSalt)();
                tx = await unirepContract.processAttestations(outputBlindedUserState, outputBlindedHashChain, falseInput, (0, circuits_1.formatProofForVerifierContract)(processAttestationProofs[i].proof));
                receipt = await tx.wait();
                (0, chai_1.expect)(receipt.status, 'Submit process attestations proof failed').to.equal(1);
                tx = await unirepContract.processAttestations(outputBlindedUserState, outputBlindedHashChain, inputBlindedUserState, (0, circuits_1.formatProofForVerifierContract)(processAttestationProofs[i].proof));
                receipt = await tx.wait();
                (0, chai_1.expect)(receipt.status, 'Submit process attestations proof failed').to.equal(1);
                console.log("Gas cost of submit a process attestations proof:", receipt.gasUsed.toString());
                const proofNullifier = (0, contracts_1.computeProcessAttestationsProofHash)(outputBlindedUserState, outputBlindedHashChain, inputBlindedUserState, (0, circuits_1.formatProofForVerifierContract)(processAttestationProofs[i].proof));
                const proofIndex = await unirepContract.getProofIndex(proofNullifier);
                proofIndexes.push(proofIndex);
            }
            isValid = await (0, circuits_1.verifyProof)(circuits_1.Circuit.userStateTransition, finalTransitionProof.proof, finalTransitionProof.publicSignals);
            (0, chai_1.expect)(isValid, 'Verify user state transition circuit off-chain failed').to.be.true;
            const transitionProof = new contracts_1.UserTransitionProof(finalTransitionProof.publicSignals, finalTransitionProof.proof);
            tx = await unirepContract.updateUserStateRoot(transitionProof, proofIndexes);
            receipt = await tx.wait();
            (0, chai_1.expect)(receipt.status, 'Submit user state transition proof failed').to.equal(1);
            console.log("Gas cost of submit a user state transition proof:", receipt.gasUsed.toString());
        });
        it('restored user state should match the user state after user state transition', async () => {
            let startTime = new Date().getTime();
            users[secondUser] = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[secondUser]);
            let endTime = new Date().getTime();
            console.log(`Gen user state from contract time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            startTime = new Date().getTime();
            const restoredUserState = await (0, core_1.genUserStateFromContract)(hardhat_1.ethers.provider, unirepContract.address, userIds[secondUser], JSON.parse(secondUserState));
            endTime = new Date().getTime();
            console.log(`Gen user state from contract with a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const epoch = 1;
            const epochTreeRoot = await users[secondUser].getUnirepStateEpochTree(epoch);
            const restoredEpochTreeRoot = await restoredUserState.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredEpochTreeRoot.toString()).equal(epochTreeRoot.toString());
            startTime = new Date().getTime();
            const restoredUserStateFromParams = (0, core_1.genUserStateFromParams)(userIds[secondUser], JSON.parse(restoredUserState.toJSON()));
            const restoredEpochTreeRootFromParams = await restoredUserStateFromParams.getUnirepStateEpochTree(epoch);
            (0, chai_1.expect)(restoredEpochTreeRootFromParams.toString()).equal(epochTreeRoot.toString());
            endTime = new Date().getTime();
            console.log(`Gen user state purely from a restored state time: ${endTime - startTime} ms (${Math.floor((endTime - startTime) / 1000)} s)`);
            const unirepEpoch = await unirepContract.currentEpoch();
            const currentEpoch = users[secondUser].getUnirepStateCurrentEpoch();
            (0, chai_1.expect)(currentEpoch).equal(unirepEpoch);
            console.log(`successfully update user state`);
            console.log('----------------------User State----------------------');
            console.log(users[secondUser].toJSON(4));
            console.log('------------------------------------------------------');
            savedUserState = users[secondUser].toJSON(4);
        });
    });
});
